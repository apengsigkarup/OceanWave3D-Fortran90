*[[[[[[DATE 13 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C[[[[[[ALIAS MA30AD
      SUBROUTINE MA30AD(NN,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,IRN,LIRN,
     +                  LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC,IPTR,IPC,U,
     +                  IFLAG)
C IF  THE USER REQUIRES A MORE CONVENIENT DATA INTERFACE THEN THE MA28
C     PACKAGE SHOULD BE USED.  THE MA28 SUBROUTINES CALL THE MA30
C     SUBROUTINES AFTER CHECKING THE USER'S INPUT DATA AND OPTIONALLY
C     USING MC23A/AD TO PERMUTE THE MATRIX TO BLOCK TRIANGULAR FORM.
C THIS PACKAGE OF SUBROUTINES (MA30A/AD, MA30B/BD, MA30C/CD AND
C     MA30D/DD) PERFORMS OPERATIONS PERTINENT TO THE SOLUTION OF A
C     GENERAL SPARSE N BY N SYSTEM OF LINEAR EQUATIONS (I.E. SOLVE
C     AX=B). STRUCTUALLY SINGULAR MATRICES ARE PERMITTED INCLUDING
C     THOSE WITH ROW OR COLUMNS CONSISTING ENTIRELY OF ZEROS (I.E.
C     INCLUDING RECTANGULAR MATRICES).  IT IS ASSUMED THAT THE
C     NON-ZEROS OF THE MATRIX A DO NOT DIFFER WIDELY IN SIZE.  IF
C     NECESSARY A PRIOR CALL OF THE SCALING SUBROUTINE MC19A/AD MAY BE
C     MADE.
C A DISCUSSION OF THE DESIGN OF THESE SUBROUTINES IS GIVEN BY DUFF AND
C     REID (ACM TRANS MATH SOFTWARE 5 PP 18-35,1979 (CSS 48)) WHILE
C     FULLER DETAILS OF THE IMPLEMENTATION ARE GIVEN IN DUFF (HARWELL
C     REPORT AERE-R 8730,1977).  THE ADDITIONAL PIVOTING OPTION IN
C     MA30A/AD AND THE USE OF DROP TOLERANCES (SEE COMMON BLOCK
C     MA30I/ID) WERE ADDED TO THE PACKAGE AFTER JOINT WORK WITH REID,
C     SCHAUMBURG, WASNIEWSKI AND ZLATEV (DUFF, REID, SCHAUMBURG,
C     WASNIEWSKI AND ZLATEV, HARWELL REPORT CSS 135, 1983).
C
C MA30A/AD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF THE
C     PERMUTATION PAQ OF A SPARSE MATRIX A, WHERE INPUT PERMUTATIONS
C     P1 AND Q1 ARE USED TO DEFINE THE DIAGONAL BLOCKS.  THERE MAY BE
C     NON-ZEROS IN THE OFF-DIAGONAL BLOCKS BUT THEY ARE UNAFFECTED BY
C     MA30A/AD. P AND P1 DIFFER ONLY WITHIN BLOCKS AS DO Q AND Q1. THE
C     PERMUTATIONS P1 AND Q1 MAY BE FOUND BY CALLING MC23A/AD OR THE
C     MATRIX MAY BE TREATED AS A SINGLE BLOCK BY USING P1=Q1=I. THE
C     MATRIX NON-ZEROS SHOULD BE HELD COMPACTLY BY ROWS, ALTHOUGH IT
C     SHOULD BE NOTED THAT THE USER CAN SUPPLY THE MATRIX BY COLUMNS
C     TO GET THE LU DECOMPOSITION OF A TRANSPOSE.
C
C THE PARAMETERS ARE...
C THIS DESCRIPTION SHOULD ALSO BE CONSULTED FOR FURTHER INFORMATION ON
C     MOST OF THE PARAMETERS OF MA30B/BD AND MA30C/CD.
C
C N  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE ORDER
C     OF THE MATRIX.  IT IS NOT ALTERED BY MA30A/AD.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. POSITIONS IDISP(2) TO
C     LICN MUST BE SET BY THE USER TO CONTAIN THE COLUMN INDICES OF
C     THE NON-ZEROS IN THE DIAGONAL BLOCKS OF P1*A*Q1. THOSE BELONGING
C     TO A SINGLE ROW MUST BE CONTIGUOUS BUT THE ORDERING OF COLUMN
C     INDICES WITH EACH ROW IS UNIMPORTANT. THE NON-ZEROS OF ROW I
C     PRECEDE THOSE OF ROW I+1,I=1,...,N-1 AND NO WASTED SPACE IS
C     ALLOWED BETWEEN THE ROWS.  ON OUTPUT THE COLUMN INDICES OF THE
C     LU DECOMPOSITION OF PAQ ARE HELD IN POSITIONS IDISP(1) TO
C     IDISP(2), THE ROWS ARE IN PIVOTAL ORDER, AND THE COLUMN INDICES
C     OF THE L PART OF EACH ROW ARE IN PIVOTAL ORDER AND PRECEDE THOSE
C     OF U. AGAIN THERE IS NO WASTED SPACE EITHER WITHIN A ROW OR
C     BETWEEN THE ROWS. ICN(1) TO ICN(IDISP(1)-1), ARE NEITHER
C     REQUIRED NOR ALTERED. IF MC23A/AD BEEN CALLED, THESE WILL HOLD
C     INFORMATION ABOUT THE OFF-DIAGONAL BLOCKS.
C A IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN WHOSE ENTRIES
C     IDISP(2) TO LICN MUST BE SET BY THE USER TO THE  VALUES OF THE
C     NON-ZERO ENTRIES OF THE MATRIX IN THE ORDER INDICATED BY  ICN.
C     ON OUTPUT A WILL HOLD THE LU FACTORS OF THE MATRIX WHERE AGAIN
C     THE POSITION IN THE MATRIX IS DETERMINED BY THE CORRESPONDING
C     VALUES IN ICN. A(1) TO A(IDISP(1)-1) ARE NEITHER REQUIRED NOR
C     ALTERED.
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE
C     LENGTH OF ARRAYS ICN AND A. IT MUST BE BIG ENOUGH FOR A AND ICN
C     TO HOLD ALL THE NON-ZEROS OF L AND U AND LEAVE SOME "ELBOW
C     ROOM".  IT IS POSSIBLE TO CALCULATE A MINIMUM VALUE FOR LICN BY
C     A PRELIMINARY RUN OF MA30A/AD. THE ADEQUACY OF THE ELBOW ROOM
C     CAN BE JUDGED BY THE SIZE OF THE COMMON BLOCK VARIABLE ICNCP. IT
C     IS NOT ALTERED BY MA30A/AD.
C LENR  IS AN INTEGER ARRAY OF LENGTH N.  ON INPUT, LENR(I) SHOULD
C     EQUAL THE NUMBER OF NON-ZEROS IN ROW I, I=1,...,N OF THE
C     DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT, LENR(I) WILL EQUAL THE
C     TOTAL NUMBER OF NON-ZEROS IN ROW I OF L AND ROW I OF U.
C LENRL  IS AN INTEGER ARRAY OF LENGTH N. ON OUTPUT FROM MA30A/AD,
C     LENRL(I) WILL HOLD THE NUMBER OF NON-ZEROS IN ROW I OF L.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. THE USER SHOULD SET IDISP(1)
C     TO BE THE FIRST AVAILABLE POSITION IN A/ICN FOR THE LU
C     DECOMPOSITION WHILE IDISP(2) IS SET TO THE POSITION IN A/ICN OF
C     THE FIRST NON-ZERO IN THE DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT,
C     IDISP(1) WILL BE UNALTERED WHILE IDISP(2) WILL BE SET TO THE
C     POSITION IN A/ICN OF THE LAST NON-ZERO OF THE LU DECOMPOSITION.
C IP  IS AN INTEGER ARRAY OF LENGTH N WHICH HOLDS A PERMUTATION OF
C     THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, THE ABSOLUTE VALUE OF
C     IP(I) MUST BE SET TO THE ROW OF A WHICH IS ROW I OF P1*A*Q1. A
C     NEGATIVE VALUE FOR IP(I) INDICATES THAT ROW I IS AT THE END OF A
C     DIAGONAL BLOCK.  ON OUTPUT FROM MA30A/AD, IP(I) INDICATES THE ROW
C     OF A WHICH IS THE I TH ROW IN PAQ. IP(I) WILL STILL BE NEGATIVE
C     FOR THE LAST ROW OF EACH BLOCK (EXCEPT THE LAST).
C IQ IS AN INTEGER ARRAY OF LENGTH N WHICH AGAIN HOLDS A
C     PERMUTATION OF THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, IQ(J)
C     MUST BE SET TO THE COLUMN OF A WHICH IS COLUMN J OF P1*A*Q1. ON
C     OUTPUT FROM MA30A/AD, THE ABSOLUTE VALUE OF IQ(J) INDICATES THE
C     COLUMN OF A WHICH IS THE J TH IN PAQ.  FOR ROWS, I SAY, IN WHICH
C     STRUCTURAL OR NUMERICAL SINGULARITY IS DETECTED IQ(I) IS
C     NEGATED.
C IRN  IS AN INTEGER ARRAY OF LENGTH LIRN USED AS WORKSPACE BY
C     MA30A/AD.
C LIRN  IS AN INTEGER VARIABLE. IT SHOULD BE GREATER THAN THE
C     LARGEST NUMBER OF NON-ZEROS IN A DIAGONAL BLOCK OF P1*A*Q1 BUT
C     NEED NOT BE AS LARGE AS LICN. IT IS THE LENGTH OF ARRAY IRN AND
C     SHOULD BE LARGE ENOUGH TO HOLD THE ACTIVE PART OF ANY BLOCK,
C     PLUS SOME "ELBOW ROOM", THE  A POSTERIORI  ADEQUACY OF WHICH CAN
C     BE ESTIMATED BY EXAMINING THE SIZE OF COMMON BLOCK VARIABLE
C     IRNCP.
C LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC ARE ALL INTEGER ARRAYS OF
C     LENGTH N WHICH ARE USED AS WORKSPACE BY MA30A/AD.  IF NSRCH IS
C     SET TO A VALUE LESS THAN OR EQUAL TO N, THEN ARRAYS LASTC AND
C     NEXTC ARE NOT REFERENCED BY MA30A/AD AND SO CAN BE DUMMIED IN
C     THE CALL TO MA30A/AD.
C IPTR,IPC ARE INTEGER ARRAYS OF LENGTH N WHICH ARE USED AS WORKSPACE
C     BY MA30A/AD.
C U  IS A REAL/DOUBLE PRECISION VARIABLE WHICH SHOULD BE SET BY THE
C     USER TO A VALUE BETWEEN 0. AND 1.0. IF LESS THAN ZERO IT IS
C     RESET TO ZERO AND IF ITS VALUE IS 1.0 OR GREATER IT IS RESET TO
C     0.9999 (0.999999999 IN D VERSION).  IT DETERMINES THE BALANCE
C     BETWEEN PIVOTING FOR SPARSITY AND FOR STABILITY, VALUES NEAR
C     ZERO EMPHASIZING SPARSITY AND VALUES NEAR ONE EMPHASIZING
C     STABILITY. WE RECOMMEND U=0.1 AS A POSIBLE FIRST TRIAL VALUE.
C     THE STABILITY CAN BE JUDGED BY A LATER CALL TO MC24A/AD OR BY
C     SETTING LBIG TO .TRUE.
C IFLAG  IS AN INTEGER VARIABLE. IT WILL HAVE A NON-NEGATIVE VALUE IF
C     MA30A/AD IS SUCCESSFUL. NEGATIVE VALUES INDICATE ERROR
C     CONDITIONS WHILE POSITIVE VALUES INDICATE THAT THE MATRIX HAS
C     BEEN SUCCESSFULLY DECOMPOSED BUT IS SINGULAR. FOR EACH NON-ZERO
C     VALUE, AN APPROPRIATE MESSAGE IS OUTPUT ON UNIT LP.  POSSIBLE
C     NON-ZERO VALUES FOR IFLAG ARE ...
C
C -1  THE MATRIX IS STRUCTUALLY SINGULAR WITH RANK GIVEN BY IRANK IN
C     COMMON BLOCK MA30F/FD.
C +1  IF, HOWEVER, THE USER WANTS THE LU DECOMPOSITION OF A
C     STRUCTURALLY SINGULAR MATRIX AND SETS THE COMMON BLOCK VARIABLE
C     ABORT1 TO .FALSE., THEN, IN THE EVENT OF SINGULARITY AND A
C     SUCCESSFUL DECOMPOSITION, IFLAG IS RETURNED WITH THE VALUE +1
C     AND NO MESSAGE IS OUTPUT.
C -2  THE MATRIX IS NUMERICALLY SINGULAR (IT MAY ALSO BE STRUCTUALLY
C     SINGULAR) WITH ESTIMATED RANK GIVEN BY IRANK IN COMMON BLOCK
C     MA30F/FD.
C +2  THE  USER CAN CHOOSE TO CONTINUE THE DECOMPOSITION EVEN WHEN A
C     ZERO PIVOT IS ENCOUNTERED BY SETTING COMMON BLOCK VARIABLE
C     ABORT2 TO .FALSE.  IF A SINGULARITY IS ENCOUNTERED, IFLAG WILL
C     THEN RETURN WITH A VALUE OF +2, AND NO MESSAGE IS OUTPUT IF THE
C     DECOMPOSITION HAS BEEN COMPLETED SUCCESSFULLY.
C -3  LIRN HAS NOT BEEN LARGE ENOUGH TO CONTINUE WITH THE
C     DECOMPOSITION.  IF THE STAGE WAS ZERO THEN COMMON BLOCK VARIABLE
C     MINIRN GIVES THE LENGTH SUFFICIENT TO START THE DECOMPOSITION ON
C     THIS BLOCK.  FOR A SUCCESSFUL DECOMPOSITION ON THIS BLOCK THE
C     USER SHOULD MAKE LIRN SLIGHTLY (SAY ABOUT N/2) GREATER THAN THIS
C     VALUE.
C -4  LICN NOT LARGE ENOUGH TO CONTINUE WITH THE DECOMPOSITION.
C -5  THE DECOMPOSITION HAS BEEN COMPLETED BUT SOME OF THE LU FACTORS
C     HAVE BEEN DISCARDED TO CREATE ENOUGH ROOM IN A/ICN TO CONTINUE
C     THE DECOMPOSITION. THE VARIABLE MINICN IN COMMON BLOCK MA30F/FD
C     THEN GIVES THE SIZE THAT LICN SHOULD BE TO ENABLE THE
C     FACTORIZATION TO BE SUCCESSFUL.  IF THE USER SETS COMMON BLOCK
C     VARIABLE ABORT3 TO .TRUE., THEN THE SUBROUTINE WILL EXIT
C     IMMEDIATELY INSTEAD OF DESTROYING ANY FACTORS AND CONTINUING.
C -6  BOTH LICN AND LIRN ARE TOO SMALL. TERMINATION HAS BEEN CAUSED BY
C     LACK OF SPACE IN IRN (SEE ERROR IFLAG= -3), BUT ALREADY SOME OF
C     THE LU FACTORS IN A/ICN HAVE BEEN LOST (SEE ERROR IFLAG= -5).
C     MINICN GIVES THE MINIMUM AMOUNT OF SPACE REQUIRED IN A/ICN FOR
C     DECOMPOSITION UP TO THIS POINT.
C
C FOR COMMENTS OF COMMON BLOCK VARIABLES SEE BLOCK DATA SUBPROGRAM.
C     .. Scalar Arguments ..
      DOUBLE PRECISION U
      INTEGER IFLAG,LICN,LIRN,NN
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN)
      INTEGER ICN(LICN),IDISP(2),IFIRST(NN),IP(NN),IPC(NN),IPTR(NN),
     +        IQ(NN),IRN(LIRN),LASTC(NN),LASTR(NN),LENC(NN),LENR(NN),
     +        LENRL(NN),NEXTC(NN),NEXTR(NN)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AANEW,AMAX,ANEW,AU,PIVR,PIVRAT,SCALE,UMAX,ZERO
      INTEGER COLUPD,DISPC,I,I1,I2,IACTIV,IBEG,IDISPC,IDROP,IDUMMY,IEND,
     +        IFILL,IFIR,II,III,IJFIR,IJP1,IJPOS,ILAST,INDROW,IOP,IPIV,
     +        IPOS,IROWS,ISING,ISRCH,ISTART,ISW,ISW1,ITOP,J,J1,J2,JBEG,
     +        JCOST,JCOUNT,JDIFF,JDUMMY,JEND,JJ,JMORE,JNEW,JNPOS,JOLD,
     +        JPIV,JPOS,JROOM,JVAL,JZER,JZERO,K,KCOST,KDROP,L,LC,LENPIV,
     +        LL,LR,MOREI,MSRCH,N,NBLOCK,NC,NNM1,NR,NUM,NZ,NZ2,NZCOL,
     +        NZMIN,NZPC,NZROW,OLDEND,OLDPIV,PIVEND,PIVOT,PIVROW,ROWI
C     ..
C     .. External Subroutines ..
      EXTERNAL MA30DD,MA30JD
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1,DMIN1,IABS,MAX0,MIN0
C     ..
C     .. Common blocks ..
      COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30FD/IRNCP,ICNCP,IRANK,MINIRN,MINICN
      COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
      DOUBLE PRECISION BIG,TOL
      INTEGER ICNCP,IRANK,IRNCP,LP,MINICN,MINIRN,NDROP,NSRCH
      LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Data statements ..
C
      DATA  UMAX/.999999999D0/
      DATA  ZERO/0.0D0/
C     ..
      MSRCH  = NSRCH
      NDROP  = 0
      MINIRN = 0
      MINICN = IDISP(1) - 1
      MOREI  = 0
      IRANK  = NN
      IRNCP  = 0
      ICNCP  = 0
      IFLAG  = 0
C RESET U IF NECESSARY.
      U      = DMIN1(U,UMAX)
C IBEG IS THE POSITION OF THE NEXT PIVOT ROW AFTER ELIMINATION STEP
C     USING IT.
      U      = DMAX1(U,ZERO)
      IBEG   = IDISP(1)
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE ACTIVE PART OF A/ICN.
      IACTIV = IDISP(2)
C NZROW IS CURRENT NUMBER OF NON-ZEROS IN ACTIVE AND UNPROCESSED PART
C     OF ROW FILE ICN.
      NZROW  = LICN - IACTIV + 1
      MINICN = NZROW + MINICN
C
C COUNT THE NUMBER OF DIAGONAL BLOCKS AND SET UP POINTERS TO THE
C     BEGINNINGS OF THE ROWS.
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
      NUM    = 1
      IPTR(1) = IACTIV
      IF (NN.EQ.1) GO TO 20
      NNM1   = NN - 1
      DO 10 I = 1,NNM1
         IF (IP(I).LT.0) NUM    = NUM + 1
         IPTR(I+1) = IPTR(I) + LENR(I)
   10 CONTINUE
C ILAST IS THE LAST ROW IN THE PREVIOUS BLOCK.
   20 ILAST  = 0
C
C ***********************************************
C ****    LU DECOMPOSITION OF BLOCK NBLOCK   ****
C ***********************************************
C
C EACH PASS THROUGH THIS LOOP PERFORMS LU DECOMPOSITION ON ONE
C     OF THE DIAGONAL BLOCKS.
      DO 1000 NBLOCK = 1,NUM
         ISTART = ILAST + 1
         DO 30 IROWS = ISTART,NN
            IF (IP(IROWS).LT.0) GO TO 40
   30    CONTINUE
         IROWS  = NN
   40    ILAST  = IROWS
C N IS THE NUMBER OF ROWS IN THE CURRENT BLOCK.
C ISTART IS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
C ILAST IS THE INDEX OF THE LAST ROW IN THE CURRENT BLOCK.
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE BLOCK.
C ITOP IS THE POSITION OF THE LAST ENTRY IN THE BLOCK.
         N      = ILAST - ISTART + 1
         IF (N.NE.1) GO TO 90
C
C CODE FOR DEALING WITH 1X1 BLOCK.
         LENRL(ILAST) = 0
         ISING  = ISTART
         IF (LENR(ILAST).NE.0) GO TO 50
C BLOCK IS STRUCTURALLY SINGULAR.
         IRANK  = IRANK - 1
         ISING  = -ISING
         IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG  = 1
         IF (.NOT.ABORT1) GO TO 80
         IDISP(2) = IACTIV
         IFLAG  = -1
         IF (LP.NE.0) WRITE (LP,FMT=99999)
C     RETURN
         GO TO 1120

   50    SCALE  = DABS(A(IACTIV))
         IF (SCALE.EQ.ZERO) GO TO 60
         IF (LBIG) BIG    = DMAX1(BIG,SCALE)
         GO TO 70

   60    ISING  = -ISING
         IRANK  = IRANK - 1
         IPTR(ILAST) = 0
         IF (IFLAG.NE.-5) IFLAG  = 2
         IF (.NOT.ABORT2) GO TO 70
         IDISP(2) = IACTIV
         IFLAG  = -2
         IF (LP.NE.0) WRITE (LP,FMT=99998)
         GO TO 1120

   70    A(IBEG) = A(IACTIV)
         ICN(IBEG) = ICN(IACTIV)
         IACTIV = IACTIV + 1
         IPTR(ISTART) = 0
         IBEG   = IBEG + 1
         NZROW  = NZROW - 1
   80    LASTR(ISTART) = ISTART
         IPC(ISTART) = -ISING
         GO TO 1000
C
C NON-TRIVIAL BLOCK.
   90    ITOP   = LICN
         IF (ILAST.NE.NN) ITOP   = IPTR(ILAST+1) - 1
C
C SET UP COLUMN ORIENTED STORAGE.
         DO 100 I = ISTART,ILAST
            LENRL(I) = 0
            LENC(I) = 0
  100    CONTINUE
         IF (ITOP-IACTIV.LT.LIRN) GO TO 110
         MINIRN = ITOP - IACTIV + 1
         PIVOT  = ISTART - 1
         GO TO 1100
C
C CALCULATE COLUMN COUNTS.
  110    DO 120 II = IACTIV,ITOP
            I      = ICN(II)
            LENC(I) = LENC(I) + 1
  120    CONTINUE
C SET UP COLUMN POINTERS SO THAT IPC(J) POINTS TO POSITION AFTER END
C     OF COLUMN J IN COLUMN FILE.
         IPC(ILAST) = LIRN + 1
         J1     = ISTART + 1
         DO 130 JJ = J1,ILAST
            J      = ILAST - JJ + J1 - 1
            IPC(J) = IPC(J+1) - LENC(J+1)
  130    CONTINUE
         DO 150 INDROW = ISTART,ILAST
            J1     = IPTR(INDROW)
            J2     = J1 + LENR(INDROW) - 1
            IF (J1.GT.J2) GO TO 150
            DO 140 JJ = J1,J2
               J      = ICN(JJ)
               IPOS   = IPC(J) - 1
               IRN(IPOS) = INDROW
               IPC(J) = IPOS
  140       CONTINUE
  150    CONTINUE
C DISPC IS THE LOWEST INDEXED ACTIVE LOCATION IN THE COLUMN FILE.
         DISPC  = IPC(ISTART)
         NZCOL  = LIRN - DISPC + 1
         MINIRN = MAX0(NZCOL,MINIRN)
         NZMIN  = 1
C
C INITIALIZE ARRAY IFIRST.  IFIRST(I) = +/- K INDICATES THAT ROW/COL
C     K HAS I NON-ZEROS.  IF IFIRST(I) = 0, THERE IS NO ROW OR COLUMN
C     WITH I NON ZEROS.
         DO 160 I = 1,N
            IFIRST(I) = 0
  160    CONTINUE
C
C COMPUTE ORDERING OF ROW AND COLUMN COUNTS.
C FIRST RUN THROUGH COLUMNS (FROM COLUMN N TO COLUMN 1).
         DO 180 JJ = ISTART,ILAST
            J      = ILAST - JJ + ISTART
            NZ     = LENC(J)
            IF (NZ.NE.0) GO TO 170
            IPC(J) = 0
            GO TO 180

  170       IF (NSRCH.LE.NN) GO TO 180
            ISW    = IFIRST(NZ)
            IFIRST(NZ) = -J
            LASTC(J) = 0
            NEXTC(J) = -ISW
            ISW1   = IABS(ISW)
            IF (ISW.NE.0) LASTC(ISW1) = J
  180    CONTINUE
C NOW RUN THROUGH ROWS (AGAIN FROM N TO 1).
         DO 210 II = ISTART,ILAST
            I      = ILAST - II + ISTART
            NZ     = LENR(I)
            IF (NZ.NE.0) GO TO 190
            IPTR(I) = 0
            LASTR(I) = 0
            GO TO 210

  190       ISW    = IFIRST(NZ)
            IFIRST(NZ) = I
            IF (ISW.GT.0) GO TO 200
            NEXTR(I) = 0
            LASTR(I) = ISW
            GO TO 210

  200       NEXTR(I) = ISW
            LASTR(I) = LASTR(ISW)
            LASTR(ISW) = I
  210    CONTINUE
C
C
C **********************************************
C ****    START OF MAIN ELIMINATION LOOP    ****
C **********************************************
         DO 980 PIVOT = ISTART,ILAST
C
C FIRST FIND THE PIVOT USING MARKOWITZ CRITERION WITH STABILITY
C     CONTROL.
C JCOST IS THE MARKOWITZ COST OF THE BEST PIVOT SO FAR,.. THIS
C     PIVOT IS IN ROW IPIV AND COLUMN JPIV.
            NZ2    = NZMIN
            JCOST  = N*N
C
C EXAMINE ROWS/COLUMNS IN ORDER OF ASCENDING COUNT.
            DO 340 L = 1,2
               PIVRAT = ZERO
               ISRCH  = 1
               LL     = L
C A PASS WITH L EQUAL TO 2 IS ONLY PERFORMED IN THE CASE OF SINGULARITY.
               DO 330 NZ = NZ2,N
                  IF (JCOST.LE. (NZ-1)**2) GO TO 420
                  IJFIR  = IFIRST(NZ)
                  IF (IJFIR) 230,220,240
  220             IF (LL.EQ.1) NZMIN  = NZ + 1
                  GO TO 330

  230             LL     = 2
                  IJFIR  = -IJFIR
                  GO TO 290

  240             LL     = 2
C SCAN ROWS WITH NZ NON-ZEROS.
                  DO 270 IDUMMY = 1,N
                     IF (JCOST.LE. (NZ-1)**2) GO TO 420
                     IF (ISRCH.GT.MSRCH) GO TO 420
                     IF (IJFIR.EQ.0) GO TO 280
C ROW IJFIR IS NOW EXAMINED.
                     I      = IJFIR
                     IJFIR  = NEXTR(I)
C FIRST CALCULATE MULTIPLIER THRESHOLD LEVEL.
                     AMAX   = ZERO
                     J1     = IPTR(I) + LENRL(I)
                     J2     = IPTR(I) + LENR(I) - 1
                     DO 250 JJ = J1,J2
                        AMAX   = DMAX1(AMAX,DABS(A(JJ)))
  250                CONTINUE
                     AU     = AMAX*U
                     ISRCH  = ISRCH + 1
C SCAN ROW FOR POSSIBLE PIVOTS
                     DO 260 JJ = J1,J2
                        IF (DABS(A(JJ)).LE.AU .AND. L.EQ.1) GO TO 260
                        J      = ICN(JJ)
                        KCOST  = (NZ-1)* (LENC(J)-1)
                        IF (KCOST.GT.JCOST) GO TO 260
                        PIVR   = ZERO
                        IF (AMAX.NE.ZERO) PIVR   = DABS(A(JJ))/AMAX
                        IF (KCOST.EQ.JCOST .AND.
     +                      (PIVR.LE.PIVRAT.OR.NSRCH.GT.NN+1)) GO TO 260
C BEST PIVOT SO FAR IS FOUND.
                        JCOST  = KCOST
                        IJPOS  = JJ
                        IPIV   = I
                        JPIV   = J
                        IF (MSRCH.GT.NN+1 .AND.
     +                      JCOST.LE. (NZ-1)**2) GO TO 420
                        PIVRAT = PIVR
  260                CONTINUE
  270             CONTINUE
C
C COLUMNS WITH NZ NON-ZEROS NOW EXAMINED.
  280             IJFIR  = IFIRST(NZ)
                  IJFIR  = -LASTR(IJFIR)
  290             IF (JCOST.LE.NZ* (NZ-1)) GO TO 420
                  IF (MSRCH.LE.NN) GO TO 330
                  DO 320 IDUMMY = 1,N
                     IF (IJFIR.EQ.0) GO TO 330
                     J      = IJFIR
                     IJFIR  = NEXTC(IJFIR)
                     I1     = IPC(J)
                     I2     = I1 + NZ - 1
C SCAN COLUMN J.
                     DO 310 II = I1,I2
                        I      = IRN(II)
                        KCOST  = (NZ-1)* (LENR(I)-LENRL(I)-1)
                        IF (KCOST.GE.JCOST) GO TO 310
C PIVOT HAS BEST MARKOWITZ COUNT SO FAR ... NOW CHECK ITS
C     SUITABILITY ON NUMERIC GROUNDS BY EXAMINING THE OTHER NON-ZEROS
C     IN ITS ROW.
                        J1     = IPTR(I) + LENRL(I)
                        J2     = IPTR(I) + LENR(I) - 1
C WE NEED A STABILITY CHECK ON SINGLETON COLUMNS BECAUSE OF POSSIBLE
C     PROBLEMS WITH UNDERDETERMINED SYSTEMS.
                        AMAX   = ZERO
                        DO 300 JJ = J1,J2
                           AMAX   = DMAX1(AMAX,DABS(A(JJ)))
                           IF (ICN(JJ).EQ.J) JPOS   = JJ
  300                   CONTINUE
                        IF (DABS(A(JPOS)).LE.AMAX*U .AND.
     +                      L.EQ.1) GO TO 310
                        JCOST  = KCOST
                        IPIV   = I
                        JPIV   = J
                        IJPOS  = JPOS
                        IF (AMAX.NE.ZERO) PIVRAT = DABS(A(JPOS))/AMAX
                        IF (JCOST.LE.NZ* (NZ-1)) GO TO 420
  310                CONTINUE
C
  320             CONTINUE
C
  330          CONTINUE
C IN THE EVENT OF SINGULARITY, WE MUST MAKE SURE ALL ROWS AND COLUMNS
C ARE TESTED.
               MSRCH  = N
C
C MATRIX IS NUMERICALLY OR STRUCTURALLY SINGULAR  ... WHICH IT IS WILL
C     BE DIAGNOSED LATER.
               IRANK  = IRANK - 1
  340       CONTINUE
C ASSIGN REST OF ROWS AND COLUMNS TO ORDERING ARRAY.
C MATRIX IS STRUCTURALLY SINGULAR.
            IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG  = 1
            IRANK  = IRANK - ILAST + PIVOT + 1
            IF (.NOT.ABORT1) GO TO 350
            IDISP(2) = IACTIV
            IFLAG  = -1
            IF (LP.NE.0) WRITE (LP,FMT=99999)
            GO TO 1120

  350       K      = PIVOT - 1
            DO 390 I = ISTART,ILAST
               IF (LASTR(I).NE.0) GO TO 390
               K      = K + 1
               LASTR(I) = K
               IF (LENRL(I).EQ.0) GO TO 380
               MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENRL(I))
               IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360
               CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.
               IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
               MOREI  = MOREI + IBEG - IDISP(1)
               IBEG   = IDISP(1)
               IF (LP.NE.0) WRITE (LP,FMT=99997)
               IFLAG  = -5
               IF (ABORT3) GO TO 1090
  360          J1     = IPTR(I)
               J2     = J1 + LENRL(I) - 1
               IPTR(I) = 0
               DO 370 JJ = J1,J2
                  A(IBEG) = A(JJ)
                  ICN(IBEG) = ICN(JJ)
                  ICN(JJ) = 0
                  IBEG   = IBEG + 1
  370          CONTINUE
               NZROW  = NZROW - LENRL(I)
  380          IF (K.EQ.ILAST) GO TO 400
  390       CONTINUE
  400       K      = PIVOT - 1
            DO 410 I = ISTART,ILAST
               IF (IPC(I).NE.0) GO TO 410
               K      = K + 1
               IPC(I) = K
               IF (K.EQ.ILAST) GO TO 990
  410       CONTINUE
C
C THE PIVOT HAS NOW BEEN FOUND IN POSITION (IPIV,JPIV) IN LOCATION
C     IJPOS IN ROW FILE.
C UPDATE COLUMN AND ROW ORDERING ARRAYS TO CORRESPOND WITH REMOVAL
C     OF THE ACTIVE PART OF THE MATRIX.
  420       ISING  = PIVOT
            IF (A(IJPOS).NE.ZERO) GO TO 430
C NUMERICAL SINGULARITY IS RECORDED HERE.
            ISING  = -ISING
            IF (IFLAG.NE.-5) IFLAG  = 2
            IF (.NOT.ABORT2) GO TO 430
            IDISP(2) = IACTIV
            IFLAG  = -2
            IF (LP.NE.0) WRITE (LP,FMT=99998)
            GO TO 1120

  430       OLDPIV = IPTR(IPIV) + LENRL(IPIV)
            OLDEND = IPTR(IPIV) + LENR(IPIV) - 1
C CHANGES TO COLUMN ORDERING.
            IF (NSRCH.LE.NN) GO TO 460
            COLUPD = NN + 1
            DO 450 JJ = OLDPIV,OLDEND
               J      = ICN(JJ)
               LC     = LASTC(J)
               NC     = NEXTC(J)
               NEXTC(J) = -COLUPD
               IF (JJ.NE.IJPOS) COLUPD = J
               IF (NC.NE.0) LASTC(NC) = LC
               IF (LC.EQ.0) GO TO 440
               NEXTC(LC) = NC
               GO TO 450

  440          NZ     = LENC(J)
               ISW    = IFIRST(NZ)
               IF (ISW.GT.0) LASTR(ISW) = -NC
               IF (ISW.LT.0) IFIRST(NZ) = -NC
  450       CONTINUE
C CHANGES TO ROW ORDERING.
  460       I1     = IPC(JPIV)
            I2     = I1 + LENC(JPIV) - 1
            DO 480 II = I1,I2
               I      = IRN(II)
               LR     = LASTR(I)
               NR     = NEXTR(I)
               IF (NR.NE.0) LASTR(NR) = LR
               IF (LR.LE.0) GO TO 470
               NEXTR(LR) = NR
               GO TO 480

  470          NZ     = LENR(I) - LENRL(I)
               IF (NR.NE.0) IFIRST(NZ) = NR
               IF (NR.EQ.0) IFIRST(NZ) = LR
  480       CONTINUE
C
C MOVE PIVOT TO POSITION LENRL+1 IN PIVOT ROW AND MOVE PIVOT ROW
C     TO THE BEGINNING OF THE AVAILABLE STORAGE.
C THE L PART AND THE PIVOT IN THE OLD COPY OF THE PIVOT ROW IS
C     NULLIFIED WHILE, IN THE STRICTLY UPPER TRIANGULAR PART, THE
C     COLUMN INDICES, J SAY, ARE OVERWRITTEN BY THE CORRESPONDING
C     ENTRY OF IQ (IQ(J)) AND IQ(J) IS SET TO THE NEGATIVE OF THE
C     DISPLACEMENT OF THE COLUMN INDEX FROM THE PIVOT ENTRY.
            IF (OLDPIV.EQ.IJPOS) GO TO 490
            AU     = A(OLDPIV)
            A(OLDPIV) = A(IJPOS)
            A(IJPOS) = AU
            ICN(IJPOS) = ICN(OLDPIV)
            ICN(OLDPIV) = JPIV
C CHECK TO SEE IF THERE IS SPACE IMMEDIATELY AVAILABLE IN A/ICN TO
C     HOLD NEW COPY OF PIVOT ROW.
  490       MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENR(IPIV))
            IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
            CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
            OLDPIV = IPTR(IPIV) + LENRL(IPIV)
            OLDEND = IPTR(IPIV) + LENR(IPIV) - 1
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.
            IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
            MOREI  = MOREI + IBEG - IDISP(1)
            IBEG   = IDISP(1)
            IF (LP.NE.0) WRITE (LP,FMT=99997)
            IFLAG  = -5
            IF (ABORT3) GO TO 1090
            IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
C THERE IS STILL NOT ENOUGH ROOM IN A/ICN.
            IFLAG  = -4
            GO TO 1090
C COPY PIVOT ROW AND SET UP IQ ARRAY.
  500       IJPOS  = 0
            J1     = IPTR(IPIV)
C
            DO 530 JJ = J1,OLDEND
               A(IBEG) = A(JJ)
               ICN(IBEG) = ICN(JJ)
               IF (IJPOS.NE.0) GO TO 510
               IF (ICN(JJ).EQ.JPIV) IJPOS  = IBEG
               ICN(JJ) = 0
               GO TO 520

  510          K      = IBEG - IJPOS
               J      = ICN(JJ)
               ICN(JJ) = IQ(J)
               IQ(J)  = -K
  520          IBEG   = IBEG + 1
  530       CONTINUE
C
            IJP1   = IJPOS + 1
            PIVEND = IBEG - 1
            LENPIV = PIVEND - IJPOS
            NZROW  = NZROW - LENRL(IPIV) - 1
            IPTR(IPIV) = OLDPIV + 1
            IF (LENPIV.EQ.0) IPTR(IPIV) = 0
C
C REMOVE PIVOT ROW (INCLUDING PIVOT) FROM COLUMN ORIENTED FILE.
            DO 560 JJ = IJPOS,PIVEND
               J      = ICN(JJ)
               I1     = IPC(J)
               LENC(J) = LENC(J) - 1
C I2 IS LAST POSITION IN NEW COLUMN.
               I2     = IPC(J) + LENC(J) - 1
               IF (I2.LT.I1) GO TO 550
               DO 540 II = I1,I2
                  IF (IRN(II).NE.IPIV) GO TO 540
                  IRN(II) = IRN(I2+1)
                  GO TO 550

  540          CONTINUE
  550          IRN(I2+1) = 0
  560       CONTINUE
            NZCOL  = NZCOL - LENPIV - 1
C
C GO DOWN THE PIVOT COLUMN AND FOR EACH ROW WITH A NON-ZERO ADD
C     THE APPROPRIATE MULTIPLE OF THE PIVOT ROW TO IT.
C WE LOOP ON THE NUMBER OF NON-ZEROS IN THE PIVOT COLUMN SINCE
C     MA30D/DD MAY CHANGE ITS ACTUAL POSITION.
C
            NZPC   = LENC(JPIV)
            IF (NZPC.EQ.0) GO TO 900
            DO 840 III = 1,NZPC
               II     = IPC(JPIV) + III - 1
               I      = IRN(II)
C SEARCH ROW I FOR NON-ZERO TO BE ELIMINATED, CALCULATE MULTIPLIER,
C     AND PLACE IT IN POSITION LENRL+1 IN ITS ROW.
C  IDROP IS THE NUMBER OF NON-ZERO ENTRIES DROPPED FROM ROW    I
C        BECAUSE THESE FALL BENEATH TOLERANCE LEVEL.
C
               IDROP  = 0
               J1     = IPTR(I) + LENRL(I)
               IEND   = IPTR(I) + LENR(I) - 1
               DO 570 JJ = J1,IEND
                  IF (ICN(JJ).NE.JPIV) GO TO 570
C IF PIVOT IS ZERO, REST OF COLUMN IS AND SO MULTIPLIER IS ZERO.
                  AU     = ZERO
                  IF (A(IJPOS).NE.ZERO) AU     = -A(JJ)/A(IJPOS)
                  IF (LBIG) BIG    = DMAX1(BIG,DABS(AU))
                  A(JJ)  = A(J1)
                  A(J1)  = AU
                  ICN(JJ) = ICN(J1)
                  ICN(J1) = JPIV
                  LENRL(I) = LENRL(I) + 1
                  GO TO 580

  570          CONTINUE
C JUMP IF PIVOT ROW IS A SINGLETON.
  580          IF (LENPIV.EQ.0) GO TO 840
C NOW PERFORM NECESSARY OPERATIONS ON REST OF NON-PIVOT ROW I.
               ROWI   = J1 + 1
               IOP    = 0
C JUMP IF ALL THE PIVOT ROW CAUSES FILL-IN.
               IF (ROWI.GT.IEND) GO TO 650
C PERFORM OPERATIONS ON CURRENT NON-ZEROS IN ROW I.
C INNERMOST LOOP.
               DO 590 JJ = ROWI,IEND
                  J      = ICN(JJ)
                  IF (IQ(J).GT.0) GO TO 590
                  IOP    = IOP + 1
                  PIVROW = IJPOS - IQ(J)
                  A(JJ)  = A(JJ) + AU*A(PIVROW)
                  IF (LBIG) BIG    = DMAX1(DABS(A(JJ)),BIG)
                  ICN(PIVROW) = -ICN(PIVROW)
                  IF (DABS(A(JJ)).LT.TOL) IDROP  = IDROP + 1
  590          CONTINUE
C
C  JUMP IF NO NON-ZEROS IN NON-PIVOT ROW HAVE BEEN REMOVED
C       BECAUSE THESE ARE BENEATH THE DROP-TOLERANCE  TOL.
C
               IF (IDROP.EQ.0) GO TO 650
C
C  RUN THROUGH NON-PIVOT ROW COMPRESSING ROW SO THAT ONLY
C      NON-ZEROS GREATER THAN   TOL   ARE STORED.  ALL NON-ZEROS
C      LESS THAN   TOL   ARE ALSO REMOVED FROM THE COLUMN STRUCTURE.
C
               JNEW   = ROWI
               DO 630 JJ = ROWI,IEND
                  IF (DABS(A(JJ)).LT.TOL) GO TO 600
                  A(JNEW) = A(JJ)
                  ICN(JNEW) = ICN(JJ)
                  JNEW   = JNEW + 1
                  GO TO 630
C
C  REMOVE NON-ZERO ENTRY FROM COLUMN STRUCTURE.
C
  600             J      = ICN(JJ)
                  I1     = IPC(J)
                  I2     = I1 + LENC(J) - 1
                  DO 610 II = I1,I2
                     IF (IRN(II).EQ.I) GO TO 620
  610             CONTINUE
  620             IRN(II) = IRN(I2)
                  IRN(I2) = 0
                  LENC(J) = LENC(J) - 1
                  IF (NSRCH.LE.NN) GO TO 630
C REMOVE COLUMN FROM COLUMN CHAIN AND PLACE IN UPDATE CHAIN.
                  IF (NEXTC(J).LT.0) GO TO 630
C JUMP IF COLUMN ALREADY IN UPDATE CHAIN.
                  LC     = LASTC(J)
                  NC     = NEXTC(J)
                  NEXTC(J) = -COLUPD
                  COLUPD = J
                  IF (NC.NE.0) LASTC(NC) = LC
                  IF (LC.EQ.0) GO TO 622
                  NEXTC(LC) = NC
                  GO TO 630

  622             NZ     = LENC(J) + 1
                  ISW    = IFIRST(NZ)
                  IF (ISW.GT.0) LASTR(ISW) = -NC
                  IF (ISW.LT.0) IFIRST(NZ) = -NC
  630          CONTINUE
               DO 640 JJ = JNEW,IEND
                  ICN(JJ) = 0
  640          CONTINUE
C THE VALUE OF IDROP MIGHT BE DIFFERENT FROM THAT CALCULATED EARLIER
C     BECAUSE, WE MAY NOW HAVE DROPPED SOME NON-ZEROS WHICH WERE NOT
C     MODIFIED BY THE PIVOT ROW.
               IDROP  = IEND + 1 - JNEW
               IEND   = JNEW - 1
               LENR(I) = LENR(I) - IDROP
               NZROW  = NZROW - IDROP
               NZCOL  = NZCOL - IDROP
               NDROP  = NDROP + IDROP
  650          IFILL  = LENPIV - IOP
C JUMP IS IF THERE IS NO FILL-IN.
               IF (IFILL.EQ.0) GO TO 750
C NOW FOR THE FILL-IN.
               MINICN = MAX0(MINICN,MOREI+IBEG-1+NZROW+IFILL+LENR(I))
C SEE IF THERE IS ROOM FOR FILL-IN.
C GET MAXIMUM SPACE FOR ROW I IN SITU.
               DO 660 JDIFF = 1,IFILL
                  JNPOS  = IEND + JDIFF
                  IF (JNPOS.GT.LICN) GO TO 670
                  IF (ICN(JNPOS).NE.0) GO TO 670
  660          CONTINUE
C THERE IS ROOM FOR ALL THE FILL-IN AFTER THE END OF THE ROW SO IT
C     CAN BE LEFT IN SITU.
C NEXT AVAILABLE SPACE FOR FILL-IN.
               IEND   = IEND + 1
               GO TO 750
C JMORE SPACES FOR FILL-IN ARE REQUIRED IN FRONT OF ROW.
  670          JMORE  = IFILL - JDIFF + 1
               I1     = IPTR(I)
C WE NOW LOOK IN FRONT OF THE ROW TO SEE IF THERE IS SPACE FOR
C     THE REST OF THE FILL-IN.
               DO 680 JDIFF = 1,JMORE
                  JNPOS  = I1 - JDIFF
                  IF (JNPOS.LT.IACTIV) GO TO 690
                  IF (ICN(JNPOS).NE.0) GO TO 700
  680          CONTINUE
  690          JNPOS  = I1 - JMORE
               GO TO 710
C WHOLE ROW MUST BE MOVED TO THE BEGINNING OF AVAILABLE STORAGE.
  700          JNPOS  = IACTIV - LENR(I) - IFILL
C JUMP IF THERE IS SPACE IMMEDIATELY AVAILABLE FOR THE SHIFTED ROW.
  710          IF (JNPOS.GE.IBEG) GO TO 730
               CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
               I1     = IPTR(I)
               IEND   = I1 + LENR(I) - 1
               JNPOS  = IACTIV - LENR(I) - IFILL
               IF (JNPOS.GE.IBEG) GO TO 730
C NO SPACE AVAILABLE SO TRY TO CREATE SOME BY THROWING AWAY PREVIOUS
C     LU DECOMPOSITION.
               MOREI  = MOREI + IBEG - IDISP(1) - LENPIV - 1
               IF (LP.NE.0) WRITE (LP,FMT=99997)
               IFLAG  = -5
               IF (ABORT3) GO TO 1090
C KEEP RECORD OF CURRENT PIVOT ROW.
               IBEG   = IDISP(1)
               ICN(IBEG) = JPIV
               A(IBEG) = A(IJPOS)
               IJPOS  = IBEG
               DO 720 JJ = IJP1,PIVEND
                  IBEG   = IBEG + 1
                  A(IBEG) = A(JJ)
                  ICN(IBEG) = ICN(JJ)
  720          CONTINUE
               IJP1   = IJPOS + 1
               PIVEND = IBEG
               IBEG   = IBEG + 1
               IF (JNPOS.GE.IBEG) GO TO 730
C THIS STILL DOES NOT GIVE ENOUGH ROOM.
               IFLAG  = -4
               GO TO 1090

  730          IACTIV = MIN0(IACTIV,JNPOS)
C MOVE NON-PIVOT ROW I.
               IPTR(I) = JNPOS
               DO 740 JJ = I1,IEND
                  A(JNPOS) = A(JJ)
                  ICN(JNPOS) = ICN(JJ)
                  JNPOS  = JNPOS + 1
                  ICN(JJ) = 0
  740          CONTINUE
C FIRST NEW AVAILABLE SPACE.
               IEND   = JNPOS
  750          NZROW  = NZROW + IFILL
C INNERMOST FILL-IN LOOP WHICH ALSO RESETS ICN.
               IDROP  = 0
               DO 830 JJ = IJP1,PIVEND
                  J      = ICN(JJ)
                  IF (J.LT.0) GO TO 820
                  ANEW   = AU*A(JJ)
                  AANEW  = DABS(ANEW)
                  IF (AANEW.GE.TOL) GO TO 760
                  IDROP  = IDROP + 1
                  NDROP  = NDROP + 1
                  NZROW  = NZROW - 1
                  MINICN = MINICN - 1
                  IFILL  = IFILL - 1
                  GO TO 830

  760             IF (LBIG) BIG    = DMAX1(AANEW,BIG)
                  A(IEND) = ANEW
                  ICN(IEND) = J
                  IEND   = IEND + 1
C
C PUT NEW ENTRY IN COLUMN FILE.
                  MINIRN = MAX0(MINIRN,NZCOL+LENC(J)+1)
                  JEND   = IPC(J) + LENC(J)
                  JROOM  = NZPC - III + 1 + LENC(J)
                  IF (JEND.GT.LIRN) GO TO 770
                  IF (IRN(JEND).EQ.0) GO TO 810
  770             IF (JROOM.LT.DISPC) GO TO 780
C COMPRESS COLUMN FILE TO OBTAIN SPACE FOR NEW COPY OF COLUMN.
                  CALL MA30DD(A,IRN,IPC(ISTART),N,DISPC,LIRN,.FALSE.)
                  IF (JROOM.LT.DISPC) GO TO 780
                  JROOM  = DISPC - 1
                  IF (JROOM.GE.LENC(J)+1) GO TO 780
C COLUMN FILE IS NOT LARGE ENOUGH.
                  GO TO 1100
C COPY COLUMN TO BEGINNING OF FILE.
  780             JBEG   = IPC(J)
                  JEND   = IPC(J) + LENC(J) - 1
                  JZERO  = DISPC - 1
                  DISPC  = DISPC - JROOM
                  IDISPC = DISPC
                  DO 790 II = JBEG,JEND
                     IRN(IDISPC) = IRN(II)
                     IRN(II) = 0
                     IDISPC = IDISPC + 1
  790             CONTINUE
                  IPC(J) = DISPC
                  JEND   = IDISPC
                  DO 800 II = JEND,JZERO
                     IRN(II) = 0
  800             CONTINUE
  810             IRN(JEND) = I
                  NZCOL  = NZCOL + 1
                  LENC(J) = LENC(J) + 1
C END OF ADJUSTMENT TO COLUMN FILE.
                  GO TO 830
C
  820             ICN(JJ) = -J
  830          CONTINUE
               IF (IDROP.EQ.0) GO TO 834
               DO 832 KDROP = 1,IDROP
                  ICN(IEND) = 0
                  IEND   = IEND + 1
  832          CONTINUE
  834          LENR(I) = LENR(I) + IFILL
C END OF SCAN OF PIVOT COLUMN.
  840       CONTINUE
C
C
C REMOVE PIVOT COLUMN FROM COLUMN ORIENTED STORAGE AND UPDATE ROW
C     ORDERING ARRAYS.
            I1     = IPC(JPIV)
            I2     = IPC(JPIV) + LENC(JPIV) - 1
            NZCOL  = NZCOL - LENC(JPIV)
            DO 890 II = I1,I2
               I      = IRN(II)
               IRN(II) = 0
               NZ     = LENR(I) - LENRL(I)
               IF (NZ.NE.0) GO TO 850
               LASTR(I) = 0
               GO TO 890

  850          IFIR   = IFIRST(NZ)
               IFIRST(NZ) = I
               IF (IFIR) 860,880,870
  860          LASTR(I) = IFIR
               NEXTR(I) = 0
               GO TO 890

  870          LASTR(I) = LASTR(IFIR)
               NEXTR(I) = IFIR
               LASTR(IFIR) = I
               GO TO 890

  880          LASTR(I) = 0
               NEXTR(I) = 0
               NZMIN  = MIN0(NZMIN,NZ)
  890       CONTINUE
C RESTORE IQ AND NULLIFY U PART OF OLD PIVOT ROW.
C    RECORD THE COLUMN PERMUTATION IN LASTC(JPIV) AND THE ROW
C    PERMUTATION IN LASTR(IPIV).
  900       IPC(JPIV) = -ISING
            LASTR(IPIV) = PIVOT
            IF (LENPIV.EQ.0) GO TO 980
            NZROW  = NZROW - LENPIV
            JVAL   = IJP1
            JZER   = IPTR(IPIV)
            IPTR(IPIV) = 0
            DO 910 JCOUNT = 1,LENPIV
               J      = ICN(JVAL)
               IQ(J)  = ICN(JZER)
               ICN(JZER) = 0
               JVAL   = JVAL + 1
               JZER   = JZER + 1
  910       CONTINUE
C ADJUST COLUMN ORDERING ARRAYS.
            IF (NSRCH.GT.NN) GO TO 920
            DO 916 JJ = IJP1,PIVEND
               J      = ICN(JJ)
               NZ     = LENC(J)
               IF (NZ.NE.0) GO TO 914
               IPC(J) = 0
               GO TO 916

  914          NZMIN  = MIN0(NZMIN,NZ)
  916       CONTINUE
            GO TO 980

  920       JJ     = COLUPD
            DO 970 JDUMMY = 1,NN
               J      = JJ
               IF (J.EQ.NN+1) GO TO 980
               JJ     = -NEXTC(J)
               NZ     = LENC(J)
               IF (NZ.NE.0) GO TO 924
               IPC(J) = 0
               GO TO 970

  924          IFIR   = IFIRST(NZ)
               LASTC(J) = 0
               IF (IFIR) 930,940,950
  930          IFIRST(NZ) = -J
               IFIR   = -IFIR
               LASTC(IFIR) = J
               NEXTC(J) = IFIR
               GO TO 970

  940          IFIRST(NZ) = -J
               NEXTC(J) = 0
               GO TO 960

  950          LC     = -LASTR(IFIR)
               LASTR(IFIR) = -J
               NEXTC(J) = LC
               IF (LC.NE.0) LASTC(LC) = J
  960          NZMIN  = MIN0(NZMIN,NZ)
  970       CONTINUE
  980    CONTINUE
C ********************************************
C ****    END OF MAIN ELIMINATION LOOP    ****
C ********************************************
C
C RESET IACTIV TO POINT TO THE BEGINNING OF THE NEXT BLOCK.
  990    IF (ILAST.NE.NN) IACTIV = IPTR(ILAST+1)
 1000 CONTINUE
C
C ********************************************
C ****    END OF DEOMPOSITION OF BLOCK    ****
C ********************************************
C
C RECORD SINGULARITY (IF ANY) IN IQ ARRAY.
      IF (IRANK.EQ.NN) GO TO 1020
      DO 1010 I = 1,NN
         IF (IPC(I).LT.0) GO TO 1010
         ISING  = IPC(I)
         IQ(ISING) = -IQ(ISING)
         IPC(I) = -ISING
 1010 CONTINUE
C
C RUN THROUGH LU DECOMPOSITION CHANGING COLUMN INDICES TO THAT OF NEW
C     ORDER AND PERMUTING LENR AND LENRL ARRAYS ACCORDING TO PIVOT
C     PERMUTATIONS.
 1020 ISTART = IDISP(1)
      IEND   = IBEG - 1
      IF (IEND.LT.ISTART) GO TO 1040
      DO 1030 JJ = ISTART,IEND
         JOLD   = ICN(JJ)
         ICN(JJ) = -IPC(JOLD)
 1030 CONTINUE
 1040 DO 1050 II = 1,NN
         I      = LASTR(II)
         NEXTR(I) = LENR(II)
         IPTR(I) = LENRL(II)
 1050 CONTINUE
      DO 1060 I = 1,NN
         LENRL(I) = IPTR(I)
         LENR(I) = NEXTR(I)
 1060 CONTINUE
C
C UPDATE PERMUTATION ARRAYS IP AND IQ.
      DO 1070 II = 1,NN
         I      = LASTR(II)
         J      = -IPC(II)
         NEXTR(I) = IABS(IP(II)+0)
         IPTR(J) = IABS(IQ(II)+0)
 1070 CONTINUE
      DO 1080 I = 1,NN
         IF (IP(I).LT.0) NEXTR(I) = -NEXTR(I)
         IP(I)  = NEXTR(I)
         IF (IQ(I).LT.0) IPTR(I) = -IPTR(I)
         IQ(I)  = IPTR(I)
 1080 CONTINUE
      IP(NN) = IABS(IP(NN)+0)
      IDISP(2) = IEND
      GO TO 1120
C
C   ***    ERROR RETURNS    ***
 1090 IDISP(2) = IACTIV
      IF (LP.EQ.0) GO TO 1120
      WRITE (LP,FMT=99996)
      GO TO 1110

 1100 IF (IFLAG.EQ.-5) IFLAG  = -6
      IF (IFLAG.NE.-6) IFLAG  = -3
      IDISP(2) = IACTIV
      IF (LP.EQ.0) GO TO 1120
      IF (IFLAG.EQ.-3) WRITE (LP,FMT=99995)
      IF (IFLAG.EQ.-6) WRITE (LP,FMT=99994)
 1110 PIVOT  = PIVOT - ISTART + 1
      WRITE (LP,FMT=99993) PIVOT,NBLOCK,ISTART,ILAST
      IF (PIVOT.EQ.0) WRITE (LP,FMT=99992) MINIRN
C
C
 1120 RETURN

99999 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS STRUCTUR',
     +       'ALLY SINGULAR')
99998 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS NUMERICA',
     +       'LLY SINGULAR')
99997 FORMAT (' LU DECOMPOSITION DESTROYED TO CREATE MORE SPACE')
99996 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE LICN NOT BIG ENOUG',
     +       'H')
99995 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE LIRN NOT BIG ENOUG',
     +       'H')
99994 FORMAT (' ERROR RETURN FROM MA30A/AD LIRN AND LICN TOO SMALL')
99993 FORMAT (' AT STAGE ',I5,' IN BLOCK ',I5,' WITH FIRST ROW ',I5,
     +       ' AND LAST ROW ',I5)
99992 FORMAT (' TO CONTINUE SET LIRN TO AT LEAST ',I8)

      END
      SUBROUTINE MA30BD(N,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,W,IW,IFLAG)
C MA30B/BD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF A
C     NEW MATRIX PAQ OF THE SAME SPARSITY PATTERN, USING INFORMATION
C     FROM A PREVIOUS CALL TO MA30A/AD. THE ENTRIES OF THE INPUT
C     MATRIX  MUST ALREADY BE IN THEIR FINAL POSITIONS IN THE LU
C     DECOMPOSITION STRUCTURE.  THIS ROUTINE EXECUTES ABOUT FIVE TIMES
C     FASTER THAN MA30A/AD.
C
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30B/BD. CONSULT MA30A/AD FOR
C     FURTHER INFORMATION ON THESE PARAMETERS.
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. IT SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN THE USER MUST SET
C     ENTRIES IDISP(1) TO IDISP(2) TO CONTAIN THE ENTRIES IN THE
C     DIAGONAL BLOCKS OF THE MATRIX PAQ WHOSE COLUMN NUMBERS ARE HELD
C     IN ICN, USING CORRESPONDING POSITIONS. NOTE THAT SOME ZEROS MAY
C     NEED TO BE HELD EXPLICITLY. ON OUTPUT ENTRIES IDISP(1) TO
C     IDISP(2) OF ARRAY A CONTAIN THE LU DECOMPOSITION OF THE DIAGONAL
C     BLOCKS OF PAQ. ENTRIES A(1) TO A(IDISP(1)-1) ARE NEITHER
C     REQUIRED NOR ALTERED BY MA30B/BD.
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE
C     LENGTH OF ARRAYS A AND ICN. IT IS NOT ALTERED BY MA30B/BD.
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED
C     BY MA30B/BD.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. IT SHOULD BE UNCHANGED SINCE
C     THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.
C IP,IQ  ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY
C     MA30B/BD.
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS
C     WORKSPACE BY MA30B/BD.
C IW  IS AN INTEGER ARRAY OF LENGTH N WHICH IS USED AS WORKSPACE BY
C     MA30B/BD.
C IFLAG  IS AN INTEGER VARIABLE. ON OUTPUT FROM MA30B/BD, IFLAG HAS
C     THE VALUE ZERO IF THE FACTORIZATION WAS SUCCESSFUL, HAS THE
C     VALUE I IF PIVOT I WAS VERY SMALL AND HAS THE VALUE -I IF AN
C     UNEXPECTED SINGULARITY WAS DETECTED AT STAGE I OF THE
C     DECOMPOSITION.
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C     .. Scalar Arguments ..
      INTEGER IFLAG,LICN,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN),W(N)
      INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),IW(N),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AU,ONE,ROWMAX,ZERO
      INTEGER I,IFIN,ILEND,IPIVJ,ISING,ISTART,J,JAY,JAYJAY,JFIN,JJ,
     +        PIVPOS
      LOGICAL STAB
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1
C     ..
C     .. Common blocks ..
      COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30GD/EPS,RMIN
      COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
      DOUBLE PRECISION BIG,EPS,RMIN,TOL
      INTEGER LP,NDROP,NSRCH
      LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Data statements ..
      DATA  ZERO/0.0D0/,ONE/1.0D0/
C     ..
      STAB   = EPS .LE. ONE
      RMIN   = EPS
      ISING  = 0
      IFLAG  = 0
      DO 10 I = 1,N
         W(I)   = ZERO
   10 CONTINUE
C SET UP POINTERS TO THE BEGINNING OF THE ROWS.
      IW(1)  = IDISP(1)
      IF (N.EQ.1) GO TO 25
      DO 20 I = 2,N
         IW(I)  = IW(I-1) + LENR(I-1)
   20 CONTINUE
C
C   ****   START  OF MAIN LOOP    ****
C AT STEP I, ROW I OF A IS TRANSFORMED TO ROW I OF L/U BY ADDING
C     APPROPRIATE MULTIPLES OF ROWS 1 TO I-1.
C     .... USING ROW-GAUSS ELIMINATION.
   25 DO 160 I = 1,N
C ISTART IS BEGINNING OF ROW I OF A AND ROW I OF L.
         ISTART = IW(I)
C IFIN IS END OF ROW I OF A AND ROW I OF U.
         IFIN   = ISTART + LENR(I) - 1
C ILEND IS END OF ROW I OF L.
         ILEND  = ISTART + LENRL(I) - 1
         IF (ISTART.GT.ILEND) GO TO 90
C LOAD ROW I OF A INTO VECTOR W.
         DO 30 JJ = ISTART,IFIN
            J      = ICN(JJ)
            W(J)   = A(JJ)
   30    CONTINUE
C
C ADD MULTIPLES OF APPROPRIATE ROWS OF  I TO I-1  TO ROW I.
         DO 70 JJ = ISTART,ILEND
            J      = ICN(JJ)
C IPIVJ IS POSITION OF PIVOT IN ROW J.
            IPIVJ  = IW(J) + LENRL(J)
C FORM MULTIPLIER AU.
            AU     = -W(J)/A(IPIVJ)
            IF (LBIG) BIG    = DMAX1(DABS(AU),BIG)
            W(J)   = AU
C AU * ROW J (U PART) IS ADDED TO ROW I.
            IPIVJ  = IPIVJ + 1
            JFIN   = IW(J) + LENR(J) - 1
            IF (IPIVJ.GT.JFIN) GO TO 70
C INNERMOST LOOP.
            IF (LBIG) GO TO 50
            DO 40 JAYJAY = IPIVJ,JFIN
               JAY    = ICN(JAYJAY)
               W(JAY) = W(JAY) + AU*A(JAYJAY)
   40       CONTINUE
            GO TO 70

   50       DO 60 JAYJAY = IPIVJ,JFIN
               JAY    = ICN(JAYJAY)
               W(JAY) = W(JAY) + AU*A(JAYJAY)
               BIG    = DMAX1(DABS(W(JAY)),BIG)
   60       CONTINUE
   70    CONTINUE
C
C RELOAD W BACK INTO A (NOW L/U)
         DO 80 JJ = ISTART,IFIN
            J      = ICN(JJ)
            A(JJ)  = W(J)
            W(J)   = ZERO
   80    CONTINUE
C WE NOW PERFORM THE STABILITY CHECKS.
   90    PIVPOS = ILEND + 1
         IF (IQ(I).GT.0) GO TO 140
C MATRIX HAD SINGULARITY AT THIS POINT IN MA30A/AD.
C IS IT THE FIRST SUCH PIVOT IN CURRENT BLOCK ?
         IF (ISING.EQ.0) ISING  = I
C DOES CURRENT MATRIX HAVE A SINGULARITY IN THE SAME PLACE ?
         IF (PIVPOS.GT.IFIN) GO TO 100
         IF (A(PIVPOS).NE.ZERO) GO TO 170
C IT DOES .. SO SET ISING IF IT IS NOT THE END OF THE CURRENT BLOCK
C CHECK TO SEE THAT APPROPRIATE PART OF L/U IS ZERO OR NULL.
  100    IF (ISTART.GT.IFIN) GO TO 120
         DO 110 JJ = ISTART,IFIN
            IF (ICN(JJ).LT.ISING) GO TO 110
            IF (A(JJ).NE.ZERO) GO TO 170
  110    CONTINUE
  120    IF (PIVPOS.LE.IFIN) A(PIVPOS) = ONE
         IF (IP(I).GT.0 .AND. I.NE.N) GO TO 160
C END OF CURRENT BLOCK ... RESET ZERO PIVOTS AND ISING.
         DO 130 J = ISING,I
            IF ((LENR(J)-LENRL(J)).EQ.0) GO TO 130
            JJ     = IW(J) + LENRL(J)
            A(JJ)  = ZERO
  130    CONTINUE
         ISING  = 0
         GO TO 160
C MATRIX HAD NON-ZERO PIVOT IN MA30A/AD AT THIS STAGE.
  140    IF (PIVPOS.GT.IFIN) GO TO 170
         IF (A(PIVPOS).EQ.ZERO) GO TO 170
         IF (.NOT.STAB) GO TO 160
         ROWMAX = ZERO
         DO 150 JJ = PIVPOS,IFIN
            ROWMAX = DMAX1(ROWMAX,DABS(A(JJ)))
  150    CONTINUE
         IF (DABS(A(PIVPOS))/ROWMAX.GE.RMIN) GO TO 160
         IFLAG  = I
         RMIN   = DABS(A(PIVPOS))/ROWMAX
C   ****    END OF MAIN LOOP    ****
  160 CONTINUE
C
      GO TO 180
C   ***   ERROR RETURN   ***
  170 IF (LP.NE.0) WRITE (LP,FMT=99999) I
      IFLAG  = -I
C
  180 RETURN

99999 FORMAT (' ERROR RETURN FROM MA30B/BD SINGULARITY DETECTED IN RO',
     +       'W',I8)

      END
      SUBROUTINE MA30CD(N,ICN,A,LICN,LENR,LENRL,LENOFF,IDISP,IP,IQ,X,W,
     +                  MTYPE)
C MA30C/CD USES THE FACTORS PRODUCED BY MA30A/AD OR MA30B/BD TO SOLVE
C     AX=B OR A TRANSPOSE X=B WHEN THE MATRIX P1*A*Q1 (PAQ) IS BLOCK
C     LOWER TRIANGULAR (INCLUDING THE CASE OF ONLY ONE DIAGONAL
C     BLOCK).
C
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30C/CD.
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX. IT IS NOT
C     ALTERED BY THE SUBROUTINE.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. ENTRIES IDISP(1) TO
C     IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO MA30A/AD. IF
C     THE MATRIX HAS MORE THAN ONE DIAGONAL BLOCK, THEN COLUMN INDICES
C     CORRESPONDING TO NON-ZEROS IN SUB-DIAGONAL BLOCKS OF PAQ MUST
C     APPEAR IN POSITIONS 1 TO IDISP(1)-1. FOR THE SAME ROW THOSE
C     ENTRIES MUST BE CONTIGUOUS, WITH THOSE IN ROW I PRECEDING THOSE
C     IN ROW I+1 (I=1,...,N-1) AND NO WASTED SPACE BETWEEN ROWS.
C     ENTRIES MAY BE IN ANY ORDER WITHIN EACH ROW. IT IS NOT ALTERED
C     BY MA30C/CD.
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN.  ENTRIES
C     IDISP(1) TO IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO
C     MA30A/AD OR MA30B/BD.  IF THE MATRIX HAS MORE THAN ONE DIAGONAL
C     BLOCK, THEN THE VALUES OF THE NON-ZEROS IN SUB-DIAGONAL BLOCKS
C     MUST BE IN POSITIONS 1 TO IDISP(1)-1 IN THE ORDER GIVEN BY ICN.
C     IT IS NOT ALTERED BY MA30C/CD.
C LICN  IS AN INTEGER VARIABLE SET TO THE SIZE OF ARRAYS ICN AND A.
C     IT IS NOT ALTERED BY MA30C/CD.
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED
C     BY MA30C/CD.
C LENOFF  IS AN INTEGER ARRAY OF LENGTH N. IF THE MATRIX PAQ (OR
C     P1*A*Q1) HAS MORE THAN ONE DIAGONAL BLOCK, THEN LENOFF(I),
C     I=1,...,N SHOULD BE SET TO THE NUMBER OF NON-ZEROS IN ROW I OF
C     THE MATRIX PAQ WHICH ARE IN SUB-DIAGONAL BLOCKS.  IF THERE IS
C     ONLY ONE DIAGONAL BLOCK THEN LENOFF(1) MAY BE SET TO -1, IN
C     WHICH CASE THE OTHER ENTRIES OF LENOFF ARE NEVER ACCESSED. IT IS
C     NOT ALTERED BY MA30C/CD.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2 WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30C/CD.
C IP,IQ ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY
C     MA30C/CD.
C X IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N. IT MUST BE SET BY
C     THE USER TO THE VALUES OF THE RIGHT HAND SIDE VECTOR B FOR THE
C     EQUATIONS BEING SOLVED.  ON EXIT FROM MA30C/CD IT WILL BE EQUAL
C     TO THE SOLUTION X REQUIRED.
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS
C     WORKSPACE BY MA30C/CD.
C MTYPE IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER. IF
C     MTYPE=1, THEN THE SOLUTION TO THE SYSTEM AX=B IS RETURNED; ANY
C     OTHER VALUE FOR MTYPE WILL RETURN THE SOLUTION TO THE SYSTEM A
C     TRANSPOSE X=B. IT IS NOT ALTERED BY MA30C/CD.
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C     .. Scalar Arguments ..
      INTEGER LICN,MTYPE,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN),W(N),X(N)
      INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),LENOFF(N),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION WI,WII,ZERO
      INTEGER I,IB,IBACK,IBLEND,IBLOCK,IEND,IFIRST,II,III,ILAST,J,J1,J2,
     +        J3,JJ,JPIV,JPIVP1,K,LJ1,LJ2,LT,LTEND,NUMBLK
      LOGICAL NEG,NOBLOC
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1,IABS
C     ..
C     .. Common blocks ..
      COMMON /MA30HD/RESID
      DOUBLE PRECISION RESID
C     ..
C     .. Data statements ..
      DATA  ZERO/0.0D0/
C     ..
C
C THE FINAL VALUE OF RESID IS THE MAXIMUM RESIDUAL FOR AN INCONSISTENT
C     SET OF EQUATIONS.
      RESID  = ZERO
C NOBLOC IS .TRUE. IF SUBROUTINE BLOCK HAS BEEN USED PREVIOUSLY AND
C     IS .FALSE. OTHERWISE.  THE VALUE .FALSE. MEANS THAT LENOFF
C     WILL NOT BE SUBSEQUENTLY ACCESSED.
      NOBLOC = LENOFF(1) .LT. 0
      IF (MTYPE.NE.1) GO TO 140
C
C WE NOW SOLVE   A * X = B.
C NEG IS USED TO INDICATE WHEN THE LAST ROW IN A BLOCK HAS BEEN
C     REACHED.  IT IS THEN SET TO TRUE WHEREAFTER BACKSUBSTITUTION IS
C     PERFORMED ON THE BLOCK.
      NEG    = .FALSE.
C IP(N) IS NEGATED SO THAT THE LAST ROW OF THE LAST BLOCK CAN BE
C     RECOGNISED.  IT IS RESET TO ITS POSITIVE VALUE ON EXIT.
      IP(N)  = -IP(N)
C PREORDER VECTOR ... W(I) = X(IP(I))
      DO 10 II = 1,N
         I      = IP(II)
         I      = IABS(I)
         W(II)  = X(I)
   10 CONTINUE
C LT HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW OF THE
C     OFF-DIAGONAL BLOCKS.
      LT     = 1
C IFIRST HOLDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
      IFIRST = 1
C IBLOCK HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW
C     OF THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS.
      IBLOCK = IDISP(1)
C IF I IS NOT THE LAST ROW OF A BLOCK, THEN A PASS THROUGH THIS LOOP
C     ADDS THE INNER PRODUCT OF ROW I OF THE OFF-DIAGONAL BLOCKS AND W
C     TO W AND PERFORMS FORWARD ELIMINATION USING ROW I OF THE LU
C     DECOMPOSITION.   IF I IS THE LAST ROW OF A BLOCK THEN, AFTER
C     PERFORMING THESE AFOREMENTIONED OPERATIONS, BACKSUBSTITUTION IS
C     PERFORMED USING THE ROWS OF THE BLOCK.
      DO 120 I = 1,N
         WI     = W(I)
         IF (NOBLOC) GO TO 30
         IF (LENOFF(I).EQ.0) GO TO 30
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
C LTEND IS THE END OF ROW I IN THE OFF-DIAGONAL BLOCKS.
         LTEND  = LT + LENOFF(I) - 1
         DO 20 JJ = LT,LTEND
            J      = ICN(JJ)
            WI     = WI - A(JJ)*W(J)
   20    CONTINUE
C LT IS SET THE BEGINNING OF THE NEXT OFF-DIAGONAL ROW.
         LT     = LTEND + 1
C SET NEG TO .TRUE. IF WE ARE ON THE LAST ROW OF THE BLOCK.
   30    IF (IP(I).LT.0) NEG    = .TRUE.
         IF (LENRL(I).EQ.0) GO TO 50
C FORWARD ELIMINATION PHASE.
C IEND IS THE END OF THE L PART OF ROW I IN THE LU DECOMPOSITION.
         IEND   = IBLOCK + LENRL(I) - 1
         DO 40 JJ = IBLOCK,IEND
            J      = ICN(JJ)
            WI     = WI + A(JJ)*W(J)
   40    CONTINUE
C IBLOCK IS ADJUSTED TO POINT TO THE START OF THE NEXT ROW.
   50    IBLOCK = IBLOCK + LENR(I)
         W(I)   = WI
         IF (.NOT.NEG) GO TO 120
C BACK SUBSTITUTION PHASE.
C J1 IS POSITION IN A/ICN AFTER END OF BLOCK BEGINNING IN ROW IFIRST
C     AND ENDING IN ROW I.
         J1     = IBLOCK
C ARE THERE ANY SINGULARITIES IN THIS BLOCK?  IF NOT, CONTINUE WITH
C     THE BACKSUBSTITUTION.
         IB     = I
         IF (IQ(I).GT.0) GO TO 70
         DO 60 III = IFIRST,I
            IB     = I - III + IFIRST
            IF (IQ(IB).GT.0) GO TO 70
            J1     = J1 - LENR(IB)
            RESID  = DMAX1(RESID,DABS(W(IB)))
            W(IB)  = ZERO
   60    CONTINUE
C ENTIRE BLOCK IS SINGULAR.
         GO TO 110
C EACH PASS THROUGH THIS LOOP PERFORMS THE BACK-SUBSTITUTION
C     OPERATIONS FOR A SINGLE ROW, STARTING AT THE END OF THE BLOCK AND
C     WORKING THROUGH IT IN REVERSE ORDER.
   70    DO 100 III = IFIRST,IB
            II     = IB - III + IFIRST
C J2 IS END OF ROW II.
            J2     = J1 - 1
C J1 IS BEGINNING OF ROW II.
            J1     = J1 - LENR(II)
C JPIV IS THE POSITION OF THE PIVOT IN ROW II.
            JPIV   = J1 + LENRL(II)
            JPIVP1 = JPIV + 1
C JUMP IF ROW  II OF U HAS NO NON-ZEROS.
            IF (J2.LT.JPIVP1) GO TO 90
            WII    = W(II)
            DO 80 JJ = JPIVP1,J2
               J      = ICN(JJ)
               WII    = WII - A(JJ)*W(J)
   80       CONTINUE
            W(II)  = WII
   90       W(II)  = W(II)/A(JPIV)
  100    CONTINUE
  110    IFIRST = I + 1
         NEG    = .FALSE.
  120 CONTINUE
C
C REORDER SOLUTION VECTOR ... X(I) = W(IQINVERSE(I))
      DO 130 II = 1,N
         I      = IQ(II)
         I      = IABS(I)
         X(I)   = W(II)
  130 CONTINUE
      IP(N)  = -IP(N)
      GO TO 320
C
C
C WE NOW SOLVE   ATRANSPOSE * X = B.
C PREORDER VECTOR ... W(I)=X(IQ(I))
  140 DO 150 II = 1,N
         I      = IQ(II)
         I      = IABS(I)
         W(II)  = X(I)
  150 CONTINUE
C LJ1 POINTS TO THE BEGINNING THE CURRENT ROW IN THE OFF-DIAGONAL
C     BLOCKS.
      LJ1    = IDISP(1)
C IBLOCK IS INITIALIZED TO POINT TO THE BEGINNING OF THE BLOCK AFTER
C     THE LAST ONE $
      IBLOCK = IDISP(2) + 1
C ILAST IS THE LAST ROW IN THE CURRENT BLOCK.
      ILAST  = N
C IBLEND POINTS TO THE POSITION AFTER THE LAST NON-ZERO IN THE
C     CURRENT BLOCK.
      IBLEND = IBLOCK
C EACH PASS THROUGH THIS LOOP OPERATES WITH ONE DIAGONAL BLOCK AND
C     THE OFF-DIAGONAL PART OF THE MATRIX CORRESPONDING TO THE ROWS
C     OF THIS BLOCK.  THE BLOCKS ARE TAKEN IN REVERSE ORDER AND THE
C     NUMBER OF TIMES THE LOOP IS ENTERED IS MIN(N,NO. BLOCKS+1).
      DO 290 NUMBLK = 1,N
         IF (ILAST.EQ.0) GO TO 300
         IBLOCK = IBLOCK - LENR(ILAST)
C THIS LOOP FINDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK..
C     IT IS FIRST AND IBLOCK IS SET TO THE POSITION OF THE BEGINNING
C     OF THIS FIRST ROW.
         DO 160 K = 1,N
            II     = ILAST - K
            IF (II.EQ.0) GO TO 170
            IF (IP(II).LT.0) GO TO 170
            IBLOCK = IBLOCK - LENR(II)
  160    CONTINUE
  170    IFIRST = II + 1
C J1 POINTS TO THE POSITION OF THE BEGINNING OF ROW I (LT PART) OR PIVOT
         J1     = IBLOCK
C FORWARD ELIMINATION.
C EACH PASS THROUGH THIS LOOP PERFORMS THE OPERATIONS FOR ONE ROW OF THE
C     BLOCK.  IF THE CORRESPONDING ENTRY OF W IS ZERO THEN THE
C     OPERATIONS CAN BE AVOIDED.
         DO 210 I = IFIRST,ILAST
            IF (W(I).EQ.ZERO) GO TO 200
C JUMP IF ROW I SINGULAR.
            IF (IQ(I).LT.0) GO TO 220
C J2 FIRST POINTS TO THE PIVOT IN ROW I AND THEN IS MADE TO POINT TO THE
C     FIRST NON-ZERO IN THE U TRANSPOSE PART OF THE ROW.
            J2     = J1 + LENRL(I)
            WI     = W(I)/A(J2)
            IF (LENR(I)-LENRL(I).EQ.1) GO TO 190
            J2     = J2 + 1
C J3 POINTS TO THE END OF ROW I.
            J3     = J1 + LENR(I) - 1
            DO 180 JJ = J2,J3
               J      = ICN(JJ)
               W(J)   = W(J) - A(JJ)*WI
  180       CONTINUE
  190       W(I)   = WI
  200       J1     = J1 + LENR(I)
  210    CONTINUE
         GO TO 240
C DEALS WITH REST OF BLOCK WHICH IS SINGULAR.
  220    DO 230 II = I,ILAST
            RESID  = DMAX1(RESID,DABS(W(II)))
            W(II)  = ZERO
  230    CONTINUE
C BACK SUBSTITUTION.
C THIS LOOP DOES THE BACK SUBSTITUTION ON THE ROWS OF THE BLOCK IN
C     THE REVERSE ORDER DOING IT SIMULTANEOUSLY ON THE L TRANSPOSE PART
C     OF THE DIAGONAL BLOCKS AND THE OFF-DIAGONAL BLOCKS.
  240    J1     = IBLEND
         DO 280 IBACK = IFIRST,ILAST
            I      = ILAST - IBACK + IFIRST
C J1 POINTS TO THE BEGINNING OF ROW I.
            J1     = J1 - LENR(I)
            IF (LENRL(I).EQ.0) GO TO 260
C J2 POINTS TO THE END OF THE L TRANSPOSE PART OF ROW I.
            J2     = J1 + LENRL(I) - 1
            DO 250 JJ = J1,J2
               J      = ICN(JJ)
               W(J)   = W(J) + A(JJ)*W(I)
  250       CONTINUE
  260       IF (NOBLOC) GO TO 280
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
            IF (LENOFF(I).EQ.0) GO TO 280
C LJ2 POINTS TO THE END OF ROW I OF THE OFF-DIAGONAL BLOCKS.
            LJ2    = LJ1 - 1
C LJ1 POINTS TO THE BEGINNING OF ROW I OF THE OFF-DIAGONAL BLOCKS.
            LJ1    = LJ1 - LENOFF(I)
            DO 270 JJ = LJ1,LJ2
               J      = ICN(JJ)
               W(J)   = W(J) - A(JJ)*W(I)
  270       CONTINUE
  280    CONTINUE
         IBLEND = J1
         ILAST  = IFIRST - 1
  290 CONTINUE
C REORDER SOLUTION VECTOR ... X(I)=W(IPINVERSE(I))
  300 DO 310 II = 1,N
         I      = IP(II)
         I      = IABS(I)
         X(I)   = W(II)
  310 CONTINUE
C
  320 RETURN

      END
      SUBROUTINE MA30DD(A,ICN,IPTR,N,IACTIV,ITOP,REALS)
C THIS SUBROUTINE PERFORMS GARBAGE COLLECTION OPERATIONS ON THE
C     ARRAYS A, ICN AND IRN.
C IACTIV IS THE FIRST POSITION IN ARRAYS A/ICN FROM WHICH THE COMPRESS
C     STARTS.  ON EXIT, IACTIV EQUALS THE POSITION OF THE FIRST ENTRY
C     IN THE COMPRESSED PART OF A/ICN
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C
C     .. Scalar Arguments ..
      INTEGER IACTIV,ITOP,N
      LOGICAL REALS
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(ITOP)
      INTEGER ICN(ITOP),IPTR(N)
C     ..
C     .. Local Scalars ..
      INTEGER J,JPOS,K,KL,KN
C     ..
C     .. Common blocks ..
      COMMON /MA30FD/IRNCP,ICNCP,IRANK,MINIRN,MINICN
      INTEGER ICNCP,IRANK,IRNCP,MINICN,MINIRN
C     ..
      IF (REALS) ICNCP  = ICNCP + 1
      IF (.NOT.REALS) IRNCP  = IRNCP + 1
C SET THE FIRST NON-ZERO ENTRY IN EACH ROW TO THE NEGATIVE OF THE
C     ROW/COL NUMBER AND HOLD THIS ROW/COL INDEX IN THE ROW/COL
C     POINTER.  THIS IS SO THAT THE BEGINNING OF EACH ROW/COL CAN
C     BE RECOGNIZED IN THE SUBSEQUENT SCAN.
      DO 10 J = 1,N
         K      = IPTR(J)
         IF (K.LT.IACTIV) GO TO 10
         IPTR(J) = ICN(K)
         ICN(K) = -J
   10 CONTINUE
      KN     = ITOP + 1
      KL     = ITOP - IACTIV + 1
C GO THROUGH ARRAYS IN REVERSE ORDER COMPRESSING TO THE BACK SO
C     THAT THERE ARE NO ZEROS HELD IN POSITIONS IACTIV TO ITOP IN ICN.
C     RESET FIRST ENTRY OF EACH ROW/COL AND POINTER ARRAY IPTR.
      DO 30 K = 1,KL
         JPOS   = ITOP - K + 1
         IF (ICN(JPOS).EQ.0) GO TO 30
         KN     = KN - 1
         IF (REALS) A(KN)  = A(JPOS)
         IF (ICN(JPOS).GE.0) GO TO 20
C FIRST NON-ZERO OF ROW/COL HAS BEEN LOCATED
         J      = -ICN(JPOS)
         ICN(JPOS) = IPTR(J)
         IPTR(J) = KN
   20    ICN(KN) = ICN(JPOS)
   30 CONTINUE
      IACTIV = KN
      RETURN

      END
      BLOCK DATA MA30JD
C ALTHOUGH ALL COMMON BLOCK VARIABLES DO NOT HAVE DEFAULT VALUES,
C     WE COMMENT ON ALL THE COMMON BLOCK VARIABLES HERE.
C
C COMMON BLOCK MA30E/ED HOLDS CONTROL PARAMETERS ....
C     COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3
C THE INTEGER LP IS THE UNIT NUMBER TO WHICH THE ERROR MESSAGES ARE
C     SENT. LP HAS A DEFAULT VALUE OF 6.  THIS DEFAULT VALUE CAN BE
C     RESET BY THE USER, IF DESIRED.  A VALUE OF 0 SUPPRESSES ALL
C     MESSAGES.
C THE LOGICAL VARIABLES ABORT1,ABORT2,ABORT3 ARE USED TO CONTROL THE
C     CONDITIONS UNDER WHICH THE SUBROUTINE WILL TERMINATE.
C IF ABORT1 IS .TRUE. THEN THE SUBROUTINE WILL EXIT  IMMEDIATELY ON
C     DETECTING STRUCTURAL SINGULARITY.
C IF ABORT2 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY ON
C     DETECTING NUMERICAL SINGULARITY.
C IF ABORT3 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY WHEN
C     THE AVAILABLE SPACE IN A/ICN IS FILLED UP BY THE PREVIOUSLY
C     DECOMPOSED, ACTIVE, AND UNDECOMPOSED PARTS OF THE MATRIX.
C THE DEFAULT VALUES FOR ABORT1,ABORT2,ABORT3 ARE SET TO .TRUE.,.TRUE.
C     AND .FALSE. RESPECTIVELY.
C
C THE VARIABLES IN THE COMMON BLOCK MA30F/FD ARE USED TO PROVIDE THE
C     USER WITH INFORMATION ON THE DECOMPOSITION.
C     COMMON /MA30FD/ IRNCP, ICNCP, IRANK, MINIRN, MINICN
C IRNCP AND ICNCP ARE INTEGER VARIABLES USED TO MONITOR THE ADEQUACY
C     OF THE ALLOCATED SPACE IN ARRAYS IRN AND A/ICN RESPECTIVELY, BY
C     TAKING ACCOUNT OF THE NUMBER OF DATA MANAGEMENT COMPRESSES
C     REQUIRED ON THESE ARRAYS. IF IRNCP OR ICNCP IS FAIRLY LARGE (SAY
C     GREATER THAN N/10), IT MAY BE ADVANTAGEOUS TO INCREASE THE SIZE
C     OF THE CORRESPONDING ARRAY(S).  IRNCP AND ICNCP ARE INITIALIZED
C     TO ZERO ON ENTRY TO MA30A/AD AND ARE INCREMENTED EACH TIME THE
C     COMPRESSING ROUTINE MA30D/DD IS ENTERED.
C ICNCP IS THE NUMBER OF COMPRESSES ON A/ICN.
C IRNCP IS THE NUMBER OF COMPRESSES ON IRN.
C IRANK IS AN INTEGER VARIABLE WHICH GIVES AN ESTIMATE (ACTUALLY AN
C     UPPER BOUND) OF THE RANK OF THE MATRIX. ON AN EXIT WITH IFLAG
C     EQUAL TO 0, THIS WILL BE EQUAL TO N.
C MINIRN IS AN INTEGER VARIABLE WHICH, AFTER A SUCCESSFUL CALL TO
C     MA30A/AD, INDICATES THE MINIMUM LENGTH TO WHICH IRN CAN BE
C     REDUCED WHILE STILL PERMITTING A SUCCESSFUL DECOMPOSITION OF THE
C     SAME MATRIX. IF, HOWEVER, THE USER WERE TO DECREASE THE LENGTH
C     OF IRN TO THAT SIZE, THE NUMBER OF COMPRESSES (IRNCP) MAY BE
C     VERY HIGH AND QUITE COSTLY. IF LIRN IS NOT LARGE ENOUGH TO BEGIN
C     THE DECOMPOSITION ON A DIAGONAL BLOCK, MINIRN WILL BE EQUAL TO
C     THE VALUE REQUIRED TO CONTINUE THE DECOMPOSITION AND IFLAG WILL
C     BE SET TO -3 OR -6. A VALUE OF LIRN SLIGHTLY GREATER THAN THIS
C     (SAY ABOUT N/2) WILL USUALLY PROVIDE ENOUGH SPACE TO COMPLETE
C     THE DECOMPOSITION ON THAT BLOCK. IN THE EVENT OF ANY OTHER
C     FAILURE MINIRN GIVES THE MINIMUM SIZE OF IRN REQUIRED FOR A
C     SUCCESSFUL DECOMPOSITION UP TO THAT POINT.
C MINICN IS AN INTEGER VARIABLE WHICH AFTER A SUCCESSFUL CALL TO
C     MA30A/AD, INDICATES THE MINIMUM SIZE OF LICN REQUIRED TO ENABLE
C     A SUCCESSFUL DECOMPOSITION. IN THE EVENT OF FAILURE WITH IFLAG=
C     -5, MINICN WILL, IF ABORT3 IS LEFT SET TO .FALSE., INDICATE THE
C     MINIMUM LENGTH THAT WOULD BE SUFFICIENT TO PREVENT THIS ERROR IN
C     A SUBSEQUENT RUN ON AN IDENTICAL MATRIX. AGAIN THE USER MAY
C     PREFER TO USE A VALUE OF ICN SLIGHTLY GREATER THAN MINICN FOR
C     SUBSEQUENT RUNS TO AVOID TOO MANY CONPRESSES (ICNCP). IN THE
C     EVENT OF FAILURE WITH IFLAG EQUAL TO ANY NEGATIVE VALUE EXCEPT
C     -4, MINICN WILL GIVE THE MINIMUM LENGTH TO WHICH LICN COULD BE
C     REDUCED TO ENABLE A SUCCESSFUL DECOMPOSITION TO THE POINT AT
C     WHICH FAILURE OCCURRED.  NOTICE THAT, ON A SUCCESSFUL ENTRY
C     IDISP(2) GIVES THE AMOUNT OF SPACE IN A/ICN REQUIRED FOR THE
C     DECOMPOSITION WHILE MINICN WILL USUALLY BE SLIGHTLY GREATER
C     BECAUSE OF THE NEED FOR "ELBOW ROOM".  IF THE USER IS VERY
C     UNSURE HOW LARGE TO MAKE LICN, THE VARIABLE MINICN CAN BE USED
C     TO PROVIDE THAT INFORMATION. A PRELIMINARY RUN SHOULD BE
C     PERFORMED WITH ABORT3 LEFT SET TO .FALSE. AND LICN ABOUT 3/2
C     TIMES AS BIG AS THE NUMBER OF NON-ZEROS IN THE ORIGINAL MATRIX.
C     UNLESS THE INITIAL PROBLEM IS VERY SPARSE (WHEN THE RUN WILL BE
C     SUCCESSFUL) OR FILLS IN EXTREMELY BADLY (GIVING AN ERROR RETURN
C     WITH IFLAG EQUAL TO -4), AN ERROR RETURN WITH IFLAG EQUAL TO -5
C     SHOULD RESULT AND MINICN WILL GIVE THE AMOUNT OF SPACE REQUIRED
C     FOR A SUCCESSFUL DECOMPOSITION.
C
C COMMON BLOCK MA30G/GD IS USED BY THE MA30B/BD ENTRY ONLY.
C     COMMON /MA30GD/ EPS, RMIN
C EPS IS A REAL/DOUBLE PRECISION VARIABLE. IT IS USED TO TEST FOR
C     SMALL PIVOTS. ITS DEFAULT VALUE IS 1.0E-4 (1.0D-4 IN D VERSION).
C     IF THE USER SETS EPS TO ANY VALUE GREATER THAN 1.0, THEN NO
C     CHECK IS MADE ON THE SIZE OF THE PIVOTS. ALTHOUGH THE ABSENCE OF
C     SUCH A CHECK WOULD FAIL TO WARN THE USER OF BAD INSTABILITY, ITS
C     ABSENCE WILL ENABLE MA30B/BD TO RUN SLIGHTLY FASTER. AN  A
C     POSTERIORI  CHECK ON THE STABILITY OF THE FACTORIZATION CAN BE
C     OBTAINED FROM MC24A/AD.
C RMIN IS A REAL/DOUBLE PRECISION VARIABLE WHICH GIVES THE USER SOME
C     INFORMATION ABOUT THE STABILITY OF THE DECOMPOSITION.  AT EACH
C     STAGE OF THE LU DECOMPOSITION THE MAGNITUDE OF THE PIVOT APIV
C     IS COMPARED WITH THE LARGEST OFF-DIAGONAL ENTRY CURRENTLY IN ITS
C     ROW (ROW OF U), ROWMAX SAY. IF THE RATIO
C                       MIN (APIV/ROWMAX)
C     WHERE THE MINIMUM IS TAKEN OVER ALL THE ROWS, IS LESS THAN EPS
C     THEN RMIN IS SET TO THIS MINIMUM VALUE AND IFLAG IS RETURNED
C     WITH THE VALUE +I WHERE I IS THE ROW IN WHICH THIS MINIMUM
C     OCCURS.  IF THE USER SETS EPS GREATER THAN ONE, THEN THIS TEST
C     IS NOT PERFORMED. IN THIS CASE, AND WHEN THERE ARE NO SMALL
C     PIVOTS RMIN WILL BE SET EQUAL TO EPS.
C
C COMMON BLOCK MA30H/HD IS USED BY MA30C/CD ONLY.
C     COMMON /MA30HD/ RESID
C RESID IS A REAL/DOUBLE PRECISION VARIABLE. IN THE CASE OF SINGULAR
C     OR RECTANGULAR MATRICES ITS FINAL VALUE WILL BE EQUAL TO THE
C     MAXIMUM RESIDUAL FOR THE UNSATISFIED EQUATIONS; OTHERWISE ITS
C     VALUE WILL BE SET TO ZERO.
C
C COMMON  BLOCK MA30I/ID CONTROLS THE USE OF DROP TOLERANCES, THE
C     MODIFIED PIVOT OPTION AND THE THE CALCULATION OF THE LARGEST
C     ENTRY IN THE FACTORIZATION PROCESS. THIS COMMON BLOCK WAS ADDED
C     TO THE MA30 PACKAGE IN FEBRUARY, 1983.
C     COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG
C TOL IS A REAL/DOUBLE PRECISION VARIABLE.  IF IT IS SET TO A POSITIVE
C     VALUE, THEN MA30A/AD WILL DROP FROM THE FACTORS ANY NON-ZERO
C     WHOSE MODULUS IS LESS THAN TOL.  THE FACTORIZATION WILL THEN
C     REQUIRE LESS STORAGE BUT WILL BE INACCURATE.  AFTER A RUN OF
C     MA30A/AD WHERE ENTRIES HAVE BEEN DROPPED, MA30B/BD  SHOULD NOT
C     BE CALLED.  THE DEFAULT VALUE FOR TOL IS 0.0.
C BIG IS A REAL/DOUBLE PRECISION VARIABLE.  IF LBIG HAS BEEN SET TO
C     .TRUE., BIG WILL BE SET TO THE LARGEST ENTRY ENCOUNTERED DURING
C     THE FACTORIZATION.
C NDROP IS AN INTEGER VARIABLE. IF TOL HAS BEEN SET POSITIVE, ON EXIT
C     FROM MA30A/AD, NDROP WILL HOLD THE NUMBER OF ENTRIES DROPPED
C     FROM THE DATA STRUCTURE.
C NSRCH IS AN INTEGER VARIABLE. IF NSRCH IS SET TO A VALUE LESS THAN
C     OR EQUAL TO N, THEN A DIFFERENT PIVOT OPTION WILL BE EMPLOYED BY
C     MA30A/AD.  THIS MAY RESULT IN DIFFERENT FILL-IN AND EXECUTION
C     TIME FOR MA30A/AD. IF NSRCH IS LESS THAN OR EQUAL TO N, THE
C     WORKSPACE ARRAYS LASTC AND NEXTC ARE NOT REFERENCED BY MA30A/AD.
C     THE DEFAULT VALUE FOR NSRCH IS 32768.
C LBIG IS A LOGICAL VARIABLE. IF LBIG IS SET TO .TRUE., THE VALUE OF
C     THE LARGEST ENTRY ENCOUNTERED IN THE FACTORIZATION BY MA30A/AD
C     IS RETURNED IN BIG.  SETTING LBIG TO .TRUE.  WILL MARGINALLY
C     INCREASE THE FACTORIZATION TIME FOR MA30A/AD AND WILL INCREASE
C     THAT FOR MA30B/BD BY ABOUT 20%.  THE DEFAULT VALUE FOR LBIG IS
C     .FALSE.
C
C     .. Common blocks ..
      COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30GD/EPS,RMIN
      COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
      DOUBLE PRECISION BIG,EPS,RMIN,TOL
      INTEGER LP,NDROP,NSRCH
      LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Data statements ..
      DATA  EPS/1.0D-4/,TOL/0.0D0/,BIG/0.0D0/
      DATA  LP/6/,NSRCH/32768/
      DATA  LBIG/.FALSE./
      DATA  ABORT1/.TRUE./,ABORT2/.TRUE./,ABORT3/.FALSE./
C     ..
      END
